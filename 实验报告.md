# 学生管理系统开发实验报告

## 目  录

一、 系统目标  
二、 系统业务需求  
三、 系统总体设计  
&nbsp;&nbsp;&nbsp;&nbsp;3.1 系统功能结构  
&nbsp;&nbsp;&nbsp;&nbsp;3.2 数据库设计  
四、 系统详细设计  
&nbsp;&nbsp;&nbsp;&nbsp;4.1 系统开发环境  
&nbsp;&nbsp;&nbsp;&nbsp;4.2 数据库设计  
五、 系统实现  
&nbsp;&nbsp;&nbsp;&nbsp;5.1 系统文件架构图  
&nbsp;&nbsp;&nbsp;&nbsp;5.2 数据库结构图  
&nbsp;&nbsp;&nbsp;&nbsp;5.3 登录模块实现  
&nbsp;&nbsp;&nbsp;&nbsp;5.4 系统主窗体实现  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.1 主界面布局  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2 管理员首页实现  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.3 学生页面实现  
&nbsp;&nbsp;&nbsp;&nbsp;5.5 学生管理模块实现  
六、 个人心得与总结  

---

## 一、系统目标

本实验旨在开发一个基于前后端分离架构的学生管理系统，通过实践掌握.NET Web API后端开发、Vue.js前端开发以及EF Core数据库操作等核心技术。系统需要实现学生信息管理、课程信息管理、成绩信息管理和系统日志管理等功能，满足管理员和学生两类用户的不同操作需求。

本实验是在完成基础Web开发学习后的一次综合性实践项目，是将前几章学习的理论知识进行实际应用的重要的实践环节。通过本项目，学生能够完整体验从需求分析、系统设计、编码实现到测试部署的完整软件开发流程，为后续的毕业设计和实际项目开发积累经验。

系统建设的核心目标包括以下几个方面：第一，构建一个功能完整、界面美观、响应迅速的学生信息管理平台，能够满足学校对 student 信息管理的基本需求；第二，实现前后端分离的系统架构，使前后端可以独立开发、独立部署，提高系统的可维护性和可扩展性；第三，运用依赖注入（Autofac）等设计模式，优化系统架构设计，体现面向对象设计的SOLID原则；第四，通过实践EF Code First数据库设计模式，掌握现代化的数据库开发流程，理解对象关系映射（ORM）的核心概念。

在技术层面，本系统采用.NET 9.0作为后端框架，结合EF Core实现数据库操作，利用Autofac实现依赖注入管理；前端采用Vue 3框架，通过Axios库与后端API进行数据交互。这种技术栈的选择既保证了系统的性能和稳定性，又便于后期的功能扩展和维护。项目的具体开发环境为Windows操作系统，后端开发工具使用Visual Studio 2022，前端开发工具使用Visual Studio Code，数据库使用SQL Server 2019 Express。

本系统的预期成果包括：完整的前后端分离学生管理系统一套，包括用户管理、学生信息管理、课程管理、成绩管理和日志管理等功能模块；系统的技术文档一套，包括需求分析报告、系统设计文档、数据库设计文档和用户操作手册；项目源代码一套，托管于Git版本控制系统，便于代码管理和团队协作。

---

## 二、系统业务需求

### 2.1 用户角色需求

本系统包含两类主要用户角色：管理员和学生。管理员拥有系统的全部管理权限，包括学生信息管理、课程信息管理、成绩信息管理和系统日志查看等；学生用户则只能查看个人的基本信息和课程成绩，无法修改任何系统数据。这种基于角色的访问控制（RBAC）设计是Web应用中最常用的权限管理方式之一。

**管理员用户**需要完成以下核心操作：添加新学生时，需要输入学生的ID、姓名、年龄和邮箱等信息，系统自动生成学生账号；编辑学生信息时，可以修改学生的任意基本信息，包括学生的ID号（需要确保新ID不与现有学生冲突）；删除学生时，系统会检查该学生是否存在选课记录，若有则提示管理员先删除相关选课记录；查询学生时，系统以表格形式展示所有学生信息，支持按姓名或ID搜索特定学生。

在课程管理方面，管理员需要能够添加新课程，包括课程名称、课程代码、学分、任课教师和课程描述等信息；编辑课程信息时，可以修改课程的任何属性；删除课程时，需要确保没有学生选修该课程；查看课程时，可以看到课程的基本信息和选修该课程的学生名单。

在成绩管理方面，管理员需要为学生录入课程成绩，选择学生和课程后，输入对应的成绩等级（A、B、C、D、F）；可以修改已录入的成绩；可以查看所有学生的成绩情况，支持按学生、按课程、按学期等多种条件筛选查询。

日志管理方面，系统自动记录所有关键操作，包括用户登录时间、IP地�、操作类型、操作结果等；管理员可以查看日志列表，支持按时间范围、操作类型、用户等条件筛选；日志数据保留最近30天的记录，超期数据自动清理。

**学生用户**的操作相对简单：首次登录使用初始密码登录，登录后系统强制要求修改密码；登录后可以查看自己的基本信息，包括姓名、年龄、邮箱等；在"我的课程"页面可以查看自己选修的所有课程列表，包括课程名称、任课教师、学分等信息；在"我的成绩"页面可以查看自己所有课程的成绩，以及系统自动计算的GPA值。

### 2.2 功能模块需求

**学生管理模块**是系统的核心功能模块之一，需要实现学生信息的增删改查功能。该模块支持按姓名、学号等条件搜索学生，显示学生基本信息、年龄、邮箱等字段。管理员可以添加新学生、编辑现有学生信息、删除不需要的学生记录，并能够查看每个学生的选课情况和成绩信息。

学生管理模块的具体功能需求包括：学生列表展示功能，需要以分页表格的形式展示所有学生信息，每页显示10条记录，支持按姓名、邮箱等字段进行模糊搜索；添加学生功能，需要提供表单界面，包含ID、姓名、年龄、邮箱等必填字段，ID字段支持自定义输入，表单提交前需要进行数据验证；编辑学生功能，点击学生列表中的"编辑"按钮后，弹出表单并填充该学生的现有信息，管理员可以修改任意字段，修改后点击"保存"提交；删除学生功能，点击"删除"按钮后，系统弹出确认对话框，确认后删除该学生记录，若删除失败（如存在关联的选课记录）则显示错误提示；查看学生详情功能，点击"查看"按钮后，显示该学生的详细信息，包括基本信息和选课成绩列表。

**课程管理模块**需要实现课程信息的增删改查功能，包括课程名称、课程代码、学分、任课教师、课程描述等信息的管理。管理员可以添加新课程、编辑课程信息、删除停开课程，并能够查看选修该课程的学生名单。

课程管理模块的具体功能需求包括：课程列表展示功能，以表格形式展示所有课程信息，包括课程名称、代码、学分、教师等字段，支持按课程名称或代码搜索；添加课程功能，提供表单界面，包含课程名称、代码、学分、教师、描述等字段，课程代码格式为"CS"开头加三位数字；编辑课程功能，选中课程后可以修改其任意信息；删除课程功能，删除前检查是否有学生选修该课程，若有则提示先解除选课关系；课程详情功能，可以查看选修该课程的学生列表，包括学生姓名、学号和成绩。

**成绩管理模块**需要实现成绩的录入、修改和查询功能，支持按学生、课程、学期等条件查询成绩。系统需要自动计算学生的GPA，并提供成绩统计分析功能，包括平均分、最高分、最低分、及格率等统计指标。

成绩管理模块的具体功能需求包括：成绩录入功能，选择学生和课程后，从下拉列表中选择成绩等级（A、B、C、D、F），提交后保存；成绩修改功能，可以修改已录入的成绩等级；成绩查询功能，支持按学生查询（查看某学生的所有课程成绩）、按课程查询（查看某课程的所有学生成绩）、按学期查询；成绩统计功能，为每个学生自动计算GPA（绩点平均分），公式为各门课程学分乘以绩点之和除以总学分；成绩分析功能，提供班级成绩分布统计，包括平均分、最高分、最低分、及格率等指标。

**日志管理模块**需要记录系统的关键操作日志，包括用户登录日志、数据修改日志、系统异常日志等。管理员可以查看、筛选和导出日志信息，便于系统审计和问题排查。

日志管理模块的具体功能需求包括：日志记录功能，系统自动记录以下操作——用户登录（记录用户名、登录时间、IP地�、登录结果）、数据新增（记录操作人、操作时间、操作类型、数据ID）、数据修改（记录操作人、操作时间、修改前后数据）、数据删除（记录操作人、操作时间、删除的数据ID）、系统异常（记录异常类型、异常信息、发生时间）；日志查询功能，支持按时间范围（日历控件选择起止日期）、操作类型（下拉选择登录/新增/修改/删除/异常）、用户名（模糊搜索）等条件筛选；日志导出功能，支持将查询结果导出为Excel或CSV格式文件。

### 2.3 性能与安全需求

系统需要满足以下性能要求：页面加载时间不超过3秒，对于包含大量数据的表格（如学生列表、课程列表），首次加载时间不超过5秒，后续分页和搜索操作响应时间不超过1秒；API接口响应时间不超过500毫秒，复杂查询接口（如成绩统计分析）响应时间不超过2秒；系统支持至少100个用户同时在线操作，在此并发量下系统响应时间不超过正常情况的1.5倍。

系统需要具备良好的错误处理机制，在出现异常时能够给用户友好的提示信息，并记录详细的错误日志供开发人员排查。前端需要处理网络异常、服务器错误、权限不足等常见错误情况，显示用户可理解的错误信息；后端需要实现全局异常捕获和处理，记录异常详细信息（包括异常类型、消息、堆栈跟踪等），返回标准化的错误响应格式。

在安全方面，系统需要实现用户身份认证和访问控制功能，防止未授权用户访问系统敏感数据。所有用户密码需要采用安全的哈希算法存储（如PBKDF2或BCrypt），禁止明文存储或使用简单哈希；API接口需要进行身份验证，使用JWT（JSON Web Token）机制实现无状态认证；敏感操作（如删除数据）需要记录操作日志，便于审计追溯。

系统还需要防范常见的Web安全威胁：SQL注入攻击——通过参数化查询和EF Core的ORM机制自动防范；XSS跨站脚本攻击——前端对用户输入进行转义处理，后端设置合理的Content-Security-Policy响应头；CSRF跨站请求伪造攻击——使用防CSRF Token机制验证请求来源；暴力破解攻击——登录接口实现失败次数限制，连续5次密码错误锁定账号15分钟。

---

## 三、系统总体设计

### 3.1 系统功能结构

本学生管理系统采用前后端分离架构设计，整体功能结构如图3-1所示。系统分为前端应用和后端服务两大部分，通过RESTful API进行数据交互。前端负责用户界面展示和交互逻辑处理，后端负责业务逻辑处理和数据持久化存储。前后端之间通过HTTP协议进行通信，数据格式采用JSON标准。

**图3-1 系统功能结构图**

后端服务采用分层架构设计，从下至上依次为：数据访问层（Data Layer）负责与数据库交互，包括DbContext、实体模型和仓储实现；业务逻辑层（Business Layer）负责核心业务逻辑处理，包括各服务类的实现；表现层（Presentation Layer）负责HTTP请求处理和响应，包括API控制器；基础设施层（Infrastructure Layer）负责认证授权、日志记录等横切关注点。

后端服务包含以下核心模块：认证授权模块负责用户身份验证和权限控制，实现了JWT令牌的生成和验证、基于角色的访问控制策略；学生管理模块处理学生信息的增删改查操作，通过StudentController提供RESTful API接口；课程管理模块处理课程信息的增删改查操作，通过CourseController提供RESTful API接口；成绩管理模块处理成绩录入、修改和统计功能，通过EnrollmentController提供RESTful API接口；日志管理模块负责系统运行日志的记录和查询，通过LogController提供日志查询API。各模块之间通过依赖注入实现解耦，便于独立开发和测试。

前端应用采用Vue 3框架开发，使用组件化方式组织代码。前端包含以下功能页面：登录页面用于用户身份认证，路由路径为"/login"；管理端首页（路由路径为"/"）展示系统概览信息和学生列表；课程管理页面（路由路径为"/courses"）实现课程信息管理功能；成绩管理页面（路由路径为"/enrollments"）实现成绩录入和查询功能；日志管理页面（路由路径为"/logs"）展示系统运行日志；学生端首页（路由路径为"/profile"）展示学生个人信息；我的成绩页面（路由路径为"/grades"）展示学生课程成绩。

系统整体的数据流程如下：用户通过浏览器访问前端页面，前端根据用户操作调用相应的API接口；后端API接口接收请求，进行身份验证和权限检查后，调用业务逻辑层处理业务；业务逻辑层通过数据访问层操作数据库，获取或修改数据；后端将处理结果封装为JSON格式返回前端；前端接收响应数据，更新页面显示或给出操作反馈。

### 3.2 数据库设计

根据业务需求分析，本系统设计了四张核心数据表：学生表（Student）、课程表（Course）、选课表（Enrollment）和用户表（User）。数据库实体关系图如图3-2所示。

**图3-2 数据库实体关系图**

**学生表（Student）**用于存储学生基本信息，主要字段包括：学生ID（主键，int类型）、学生姓名（nvarchar(50)）、年龄（int）、电子邮箱（nvarchar(100)）。系统预设了四名测试学生：张三（ID: 1001）、李四（ID: 1002）、王五（ID: 1003）、张艳艳（ID: 1004），这些数据通过EF Core的HasData方法在数据库创建时自动填充。

学生表的SQL建表语句如下：

```sql
CREATE TABLE [Student] (
    [Id] INT NOT NULL PRIMARY KEY,
    [Name] NVARCHAR(50) NOT NULL,
    [Age] INT NOT NULL,
    [Email] NVARCHAR(100) NOT NULL
);
```

**课程表（Course）**用于存储课程信息，主要字段包括：课程ID（主键，int类型）、课程名称（nvarchar(100)）、课程描述（nvarchar(500)）、学分（int）、课程代码（nvarchar(20)）、任课教师（nvarchar(50)）。系统预设了四门课程：计算机网络（CS205，4学分，赵教授）、数据库系统（CS305，3学分，钱老师）、人工智能基础（CS401，4学分，孙教授）、前端开发技术（CS310，3学分，周老师）。

课程表的SQL建表语句如下：

```sql
CREATE TABLE [Course] (
    [Id] INT NOT NULL PRIMARY KEY,
    [Title] NVARCHAR(100) NOT NULL,
    [Description] NVARCHAR(500) NOT NULL,
    [Credits] INT NOT NULL,
    [Code] NVARCHAR(20) NOT NULL,
    [Instructor] NVARCHAR(50) NOT NULL
);
```

**选课表（Enrollment）**用于存储学生选课和成绩信息，主要字段包括：记录ID（主键，int类型）、学生ID（外键，关联Student表）、课程ID（外键，关联Course表）、成绩等级（tinyint类型，使用枚举存储A=0, B=1, C=2, D=3, F=4）。选课表关联学生表和课程表，形成多对多的选课关系。系统预设了9条选课记录，覆盖所有学生和课程的组合。

选课表的SQL建表语句如下：

```sql
CREATE TABLE [Enrollment] (
    [Id] INT NOT NULL PRIMARY KEY,
    [StudentId] INT NOT NULL,
    [CourseId] INT NOT NULL,
    [Grade] TINYINT NOT NULL,
    CONSTRAINT [FK_Enrollment_Student] FOREIGN KEY ([StudentId]) 
        REFERENCES [Student]([Id]),
    CONSTRAINT [FK_Enrollment_Course] FOREIGN KEY ([CourseId]) 
        REFERENCES [Course]([Id])
);
```

**用户表（User）**用于存储系统用户认证信息，主要字段包括：用户ID（主键，int类型）、用户名（nvarchar(50)，唯一索引）、密码哈希（nvarchar(200)）、角色（nvarchar(20)，值为"Admin"或"Student"）、学生ID（外键，可空，关联Student表）。系统预设了一个管理员用户（用户名admin，密码admin123）和四个学生用户（用户名1001-1004，密码password123）。

用户表的SQL建表语句如下：

```sql
CREATE TABLE [User] (
    [Id] INT NOT NULL PRIMARY KEY,
    [Username] NVARCHAR(50) NOT NULL UNIQUE,
    [PasswordHash] NVARCHAR(200) NOT NULL,
    [Role] NVARCHAR(20) NOT NULL,
    [StudentId] INT NULL,
    CONSTRAINT [FK_User_Student] FOREIGN KEY ([StudentId]) 
        REFERENCES [Student]([Id])
);
```

数据库表之间存在以下关联关系：Student与Enrollment是一对多关系，通过StudentId外键关联；Course与Enrollment是一对多关系，通过CourseId外键关联；User与Student是一对一关系，通过StudentId外键关联。这种关系设计确保了数据的完整性和一致性。

---

## 四、系统详细设计

### 4.1 系统开发环境

本系统的开发环境配置如下：操作系统为Windows 11，后端开发工具使用Visual Studio 2022（版本17.8.0），运行环境为.NET 9.0（SDK版本9.0.100），数据库使用SQL Server 2019 Express；前端开发工具使用Visual Studio Code（版本1.85.0），运行时使用Node.js 20.10.0和npm包管理器（版本10.2.3）。整个项目采用Git进行版本控制，开发目录为e:\webtest，远程仓库托管于GitHub。

后端项目结构采用分层架构组织，目录结构如下：

```
Backend/
├── Controllers/          # API控制器层
│   ├── AuthController.cs      # 认证控制器
│   ├── StudentController.cs   # 学生管理控制器
│   ├── CourseController.cs    # 课程管理控制器
│   ├── EnrollmentController.cs # 成绩管理控制器
│   └── LogController.cs       # 日志管理控制器
├── Data/                # 数据访问层
│   └── SchoolContext.cs       # EF Core数据库上下文
├── Models/              # 实体模型层
│   ├── Student.cs            # 学生实体
│   ├── Course.cs             # 课程实体
│   ├── Enrollment.cs         # 选课实体
│   ├── User.cs               # 用户实体
│   └── Auth/                 # 认证相关模型
│       ├── LoginDto.cs        # 登录请求DTO
│       └── JwtSettings.cs     # JWT配置
├── Services/            # 业务逻辑层
│   └── JwtService.cs         # JWT服务
├── Program.cs           # 程序入口
└── appsettings.json     # 配置文件
```

前端项目结构采用Vue 3组件化架构组织，目录结构如下：

```
frontend/
├── src/
│   ├── components/      # 功能组件
│   │   ├── Login.vue         # 登录组件
│   │   ├── StudentManagement.vue  # 学生管理组件
│   │   ├── CourseManagement.vue   # 课程管理组件
│   │   ├── EnrollmentManagement.vue # 成绩管理组件
│   │   ├── LogViewer.vue          # 日志查看组件
│   │   ├── StudentProfile.vue     # 学生个人中心
│   │   ├── MyGrades.vue           # 我的成绩组件
│   │   └── MyCourses.vue          # 我的课程组件
│   ├── services/        # API服务
│   │   └── api.js            # Axios封装
│   ├── router/          # 路由配置
│   │   └── index.js          # 路由定义
│   ├── App.vue          # 根组件
│   └── main.js          # 入口文件
├── public/              # 静态资源
├── index.html           # HTML模板
├── package.json         # 依赖配置
└── vite.config.js       # Vite配置
```

主要依赖包及其版本信息如下：

**后端依赖包**：
- Microsoft.AspNetCore.Authentication.JwtBearer v9.0.0：用于实现JWT认证
- Microsoft.EntityFrameworkCore v9.0.0：ORM框架核心包
- Microsoft.EntityFrameworkCore.SqlServer v9.0.0：SQL Server数据库提供程序
- Microsoft.EntityFrameworkCore.Design v9.0.0：设计时工具支持
- Autofac.Extensions.DependencyInjection v10.0.0：依赖注入容器
- Serilog.AspNetCore v8.0.0：日志框架
- Swashbuckle.AspNetCore v6.5.0：API文档生成

**前端依赖包**：
- vue v3.4.21：核心框架
- vue-router v4.2.5：路由管理
- axios v1.6.7：HTTP客户端
- vite v5.1.0：构建工具
- @vitejs/plugin-vue v5.0.4：Vue插件

### 4.2 数据库设计

**4.2.1 实体模型设计**

本系统使用EF Core的Code First模式进行数据库设计，通过定义实体模型类来描述数据库表结构。实体模型类位于Backend/Models目录下，采用C#类定义，属性对应数据库表的字段。

学生实体（Student）的完整代码实现如下：

```csharp
namespace Backend.Models
{
    public class Student
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public int Age { get; set; }
        public string Email { get; set; }
        public List<Enrollment>? Enrollments { get; set; }
    }
}
```

学生实体包含四个基本属性和一个导航属性。Id属性作为主键，使用int类型，对应数据库的INT类型；Name属性存储学生姓名，string类型对应NVARCHAR(50)；Age属性存储学生年龄，int类型对应INT；Email属性存储学生邮箱，string类型对应NVARCHAR(100)；Enrollments是一个导航属性，用于建立与选课记录的一对多关系，通过EF Core的延迟加载特性，当访问该属性时会自动从数据库加载相关数据。

课程实体（Course）的完整代码实现如下：

```csharp
namespace Backend.Models
{
    public class Course
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string Description { get; set; }
        public int Credits { get; set; }
        public string Code { get; set; }
        public string Instructor { get; set; }
    }
}
```

课程实体包含六个属性。Id为主键；Title存储课程名称；Description存储课程详细描述；Credits存储学分值；Code存储课程代码（如"CS205"）；Instructor存储任课教师姓名。

选课实体（Enrollment）的完整代码实现如下：

```csharp
namespace Backend.Models
{
    public class Enrollment
    {
        public int Id { get; set; }
        public int StudentId { get; set; }
        public int CourseId { get; set; }
        public Grade Grade { get; set; }
        
        public Student? Student { get; set; }
        public Course? Course { get; set; }
    }
    
    public enum Grade
    {
        A = 0,
        B = 1,
        C = 2,
        D = 3,
        F = 4
    }
}
```

选课实体使用枚举类型存储成绩等级，包括A（优秀）、B（良好）、C（中等）、D（及格）、F（不及格）五个等级。这种设计使得数据存储更加规范，同时便于后续的成绩统计分析。

用户实体（User）的完整代码实现如下：

```csharp
namespace Backend.Models
{
    public class User
    {
        public int Id { get; set; }
        public string Username { get; set; }
        public string PasswordHash { get; set; }
        public string Role { get; set; }
        public int? StudentId { get; set; }
        
        public Student? Student { get; set; }
    }
}
```

用户实体的Role属性用于区分用户角色，"Admin"表示管理员，"Student"表示学生；StudentId属性用于建立与学生记录的一对一关联，学生用户的该字段不为空，管理用户的该字段为空。

**4.2.2 数据库上下文配置**

数据库上下文类SchoolContext负责实体与数据库表的映射配置，继承自DbContext类。完整代码如下：

```csharp
using Backend.Models;
using Microsoft.EntityFrameworkCore;

namespace Backend.Data
{
    public class SchoolContext : DbContext
    {
        public SchoolContext(DbContextOptions<SchoolContext> options) : base(options)
        {
        }

        public DbSet<Student> Students { get; set; }
        public DbSet<Course> Courses { get; set; }
        public DbSet<Enrollment> Enrollments { get; set; }
        public DbSet<User> Users { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // 配置Student表，Id不是标识列，而是手动指定
            modelBuilder.Entity<Student>()
                .ToTable("Student")
                .Property(s => s.Id)
                .ValueGeneratedNever();
            
            modelBuilder.Entity<Course>().ToTable("Course");
            modelBuilder.Entity<Enrollment>().ToTable("Enrollment");
            modelBuilder.Entity<User>().ToTable("User");

            // 学生种子数据
            modelBuilder.Entity<Student>().HasData(
                new Student { Id = 1001, Name = "张三", Age = 20, Email = "zhangsan@example.com" },
                new Student { Id = 1002, Name = "李四", Age = 21, Email = "lisi@example.com" },
                new Student { Id = 1003, Name = "王五", Age = 20, Email = "wangwu@example.com" },
                new Student { Id = 1004, Name = "张艳艳", Age = 20, Email = "zhangyanyan@example.com" }
            );

            // 课程种子数据
            modelBuilder.Entity<Course>().HasData(
                new Course { Id = 1, Title = "计算机网络", Description = "计算机网络基础，包括网络协议、TCP/IP模型、路由与交换、网络安全等", Credits = 4, Code = "CS205", Instructor = "赵教授" },
                new Course { Id = 2, Title = "数据库系统", Description = "数据库原理与应用，包括关系型数据库设计、SQL语言、事务管理、索引优化等", Credits = 3, Code = "CS305", Instructor = "钱老师" },
                new Course { Id = 3, Title = "人工智能基础", Description = "人工智能导论，包括机器学习、深度学习、自然语言处理、计算机视觉等基础概念", Credits = 4, Code = "CS401", Instructor = "孙教授" },
                new Course { Id = 4, Title = "前端开发技术", Description = "现代前端开发技术，包括HTML5、CSS3、JavaScript、Vue.js框架及响应式设计", Credits = 3, Code = "CS310", Instructor = "周老师" }
            );

            // 选课种子数据
            modelBuilder.Entity<Enrollment>().HasData(
                new Enrollment { Id = 1, StudentId = 1001, CourseId = 1, Grade = Grade.A },
                new Enrollment { Id = 2, StudentId = 1001, CourseId = 2, Grade = Grade.A },
                new Enrollment { Id = 3, StudentId = 1001, CourseId = 3, Grade = Grade.B },
                new Enrollment { Id = 4, StudentId = 1002, CourseId = 1, Grade = Grade.C },
                new Enrollment { Id = 5, StudentId = 1002, CourseId = 3, Grade = Grade.A },
                new Enrollment { Id = 6, StudentId = 1002, CourseId = 4, Grade = Grade.B },
                new Enrollment { Id = 7, StudentId = 1003, CourseId = 2, Grade = Grade.B },
                new Enrollment { Id = 8, StudentId = 1003, CourseId = 3, Grade = Grade.A },
                new Enrollment { Id = 9, StudentId = 1003, CourseId = 4, Grade = Grade.A }
            );

            // 用户种子数据（密码均为password123的哈希值）
            modelBuilder.Entity<User>().HasData(
                new User { Id = 1, Username = "admin", PasswordHash = "AQAAAAEAACcQAAAAEF54t0J1cM6G4v9c3M0Z6X5Y4W3V2U1T0S9R8Q7P6O5N4M3L2K1J0I", Role = "Admin" },
                new User { Id = 2, Username = "1001", PasswordHash = "AQAAAAEAACcQAAAAEF54t0J1cM6G4v9c3M0Z6X5Y4W3V2U1T0S9R8Q7P6O5N4M3L2K1J0I", Role = "Student", StudentId = 1001 },
                new User { Id = 3, Username = "1002", PasswordHash = "AQAAAAEAACcQAAAAEF54t0J1cM6G4v9c3M0Z6X5Y4W3V2U1T0S9R8Q7P6O5N4M3L2K1J0I", Role = "Student", StudentId = 1002 },
                new User { Id = 4, Username = "1003", PasswordHash = "AQAAAAEAACcQAAAAEF54t0J1cM6G4v9c3M0Z6X5Y4W3V2U1T0S9R8Q7P6O5N4M3L2K1J0I", Role = "Student", StudentId = 1003 },
                new User { Id = 5, Username = "1004", PasswordHash = "AQAAAAEAACcQAAAAEF54t0J1cM6G4v9c3M0Z6X5Y4W3V2U1T0S9R8Q7P6O5N4M3L2K1J0I", Role = "Student", StudentId = 1004 }
            );
        }
    }
}
```

数据库上下文配置的关键点包括：通过ValueGeneratedNever()方法配置Student实体的Id属性为手动指定值，而非数据库自动生成；通过HasData方法配置种子数据，在数据库创建时自动填充初始数据；通过ToTable方法指定实体对应的数据库表名称。

**4.2.3 数据库连接配置**

在Program.cs中配置数据库连接、自动迁移和依赖注入等功能，核心代码如下：

```csharp
using Backend.Data;
using Backend.Models.Auth;
using Backend.Services;
using Autofac;
using Autofac.Extensions.DependencyInjection;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Serilog;
using System.Text;

// 配置Serilog日志
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .WriteTo.Console()
    .WriteTo.File("logs/app-.txt", rollingInterval: RollingInterval.Day)
    .CreateLogger();

var builder = WebApplication.CreateBuilder(args);
builder.Host.UseSerilog();

// 配置数据库连接
builder.Services.AddDbContext<SchoolContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// 配置Autofac依赖注入容器
builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());
builder.Host.ConfigureContainer<ContainerBuilder>(containerBuilder =>
{
    containerBuilder.RegisterType<JwtService>().AsSelf().InstancePerLifetimeScope();
    var jwtSettings = new JwtSettings();
    containerBuilder.RegisterInstance(jwtSettings).AsSelf().SingleInstance();
});

// 配置JWT认证
var jwtSettingsForAuth = new JwtSettings();
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = jwtSettingsForAuth.Issuer,
        ValidAudience = jwtSettingsForAuth.Audience,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettingsForAuth.SecretKey)),
        NameClaimType = System.Security.Claims.ClaimTypes.Name,
        RoleClaimType = System.Security.Claims.ClaimTypes.Role
    };
});

// 配置CORS跨域
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", builder =>
    {
        builder.AllowAnyOrigin()
               .AllowAnyMethod()
               .AllowAnyHeader();
    });
});

// 配置控制器和JSON序列化
builder.Services.AddControllers().AddJsonOptions(options =>
{
    options.JsonSerializerOptions.PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase;
});

var app = builder.Build();

// 自动创建数据库并应用种子数据
using (var scope = app.Services.CreateScope())
{
    var dbContext = scope.ServiceProvider.GetRequiredService<SchoolContext>();
    dbContext.Database.EnsureDeleted();  // 删除现有数据库
    dbContext.Database.EnsureCreated();  // 创建新数据库并应用种子数据
}

// 配置HTTP请求管道
app.UseCors("AllowAll");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

数据库连接字符串配置在appsettings.json文件中：

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost\\SQLEXPRESS;Database=SchoolDB;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=true"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  },
  "AllowedHosts": "*"
}
```

---

## 五、系统实现

### 5.1 系统文件架构图

**图5-1 后端项目文件架构图**

后端项目采用分层架构组织，目录结构清晰明了。Controllers目录存放所有API控制器，负责处理HTTP请求并返回响应；Models目录存放实体模型类，定义数据结构；Data目录存放DbContext和相关数据访问配置；Services目录存放业务逻辑服务类；Program.cs是程序入口点，负责服务配置和管道构建。

后端项目的技术架构采用三层架构设计：表现层（Presentation Layer）由API控制器组成，负责接收HTTP请求、参数验证、调用业务层方法并返回响应；业务逻辑层（Business Logic Layer）由控制器内的业务方法组成，负责处理核心业务逻辑；数据访问层（Data Access Layer）由DbContext和仓储方法组成，负责与数据库交互。

**图5-2 前端项目文件架构图**

前端项目采用Vue 3组件化架构组织。src/components目录存放所有功能组件，每个组件包含模板（template）、脚本（script）和样式（style）三部分；src/services目录存放API调用服务封装，通过Axios库与后端通信；src/router目录存放路由配置，定义页面导航规则；App.vue是应用根组件，负责整体布局和路由出口。

前端项目的目录组织遵循Vue 3的Composition API最佳实践，将相关逻辑组织在一起，提高代码的可维护性和复用性。公共组件（如表单组件、表格组件、模态框组件）可以提取到独立的components目录中复用。

### 5.2 数据库结构图

**图5-3 数据库表结构详图**

数据库包含四张核心数据表，它们之间的关联关系如下：学生表（Student）与选课表（Enrollment）是一对多关系，一个学生可以有多条选课记录，通过StudentId外键建立关联；课程表（Course）与选课表（Enrollment）是一对多关系，一门课程可以被多个学生选修，通过CourseId外键建立关联；用户表（User）与学生表（Student）是一对一关系，每个用户对应一个学生信息，通过StudentId外键建立关联。

数据库表之间还存在以下约束关系：Student表的Id是主键，Enrollment表的StudentId和CourseId是外键，形成多对多关系的中间表；User表的StudentId是外键，引用Student表的Id，当Student记录被删除时，对应的User记录的StudentId应设置为NULL；Enrollment表的Grade字段使用TINYINT类型存储枚举值，对应Grade枚举的定义。

选课表通过外键约束关联学生表和课程表，确保数据的完整性和一致性。当插入Enrollment记录时，数据库会检查对应的Student和Course记录是否存在；当删除Student或Course记录时，若存在关联的Enrollment记录，则数据库会阻止删除操作（除非设置了级联删除）。

系统采用Code First模式开发，数据库结构通过实体模型的配置自动生成，支持自动迁移功能。在开发阶段，使用dbContext.Database.EnsureDeleted()和dbContext.Database.EnsureCreated()方法实现每次启动时重建数据库并应用种子数据；在生产环境中，应使用EF Core的迁移命令（Add-Migration、Update-Migration）管理数据库结构变更。

### 5.3 登录模块实现

登录模块是系统的入口，负责用户身份认证和JWT令牌生成。登录模块采用JWT（JSON Web Token）机制实现无状态认证，用户登录成功后获得一个Token，后续请求携带该Token进行身份验证。

**后端登录接口实现**：

认证控制器AuthController负责处理用户登录请求，完整代码如下：

```csharp
using Backend.Data;
using Backend.Models.Auth;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;

namespace Backend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly SchoolContext _context;
        private readonly ILogger<AuthController> _logger;
        private readonly JwtSettings _jwtSettings;

        public AuthController(SchoolContext context, ILogger<AuthController> logger, JwtSettings jwtSettings)
        {
            _context = context;
            _logger = logger;
            _jwtSettings = jwtSettings;
        }

        [HttpPost("login")]
        public IActionResult Login([FromBody] LoginDto loginDto)
        {
            try
            {
                var user = _context.Users
                    .FirstOrDefault(u => u.Username == loginDto.Username);

                if (user == null)
                {
                    _logger.LogWarning("登录失败：用户不存在 ({Username})", loginDto.Username);
                    return BadRequest("用户名或密码错误");
                }

                // 简化验证，实际项目应使用密码哈希验证
                if (user.PasswordHash != loginDto.Password)
                {
                    _logger.LogWarning("登录失败：密码错误 ({Username})", loginDto.Username);
                    return BadRequest("用户名或密码错误");
                }

                // 生成JWT令牌
                var token = GenerateToken(user.Username, user.Role);
                
                _logger.LogInformation("用户登录成功: {Username}", user.Username);
                return Ok(new { 
                    token, 
                    role = user.Role, 
                    username = user.Username,
                    userId = user.StudentId
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "登录过程发生错误");
                return StatusCode(500, "服务器内部错误");
            }
        }

        private string GenerateToken(string username, string role)
        {
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));
            var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var claims = new[]
            {
                new Claim(ClaimTypes.Name, username),
                new Claim(ClaimTypes.Role, role)
            };

            var token = new JwtSecurityToken(
                issuer: _jwtSettings.Issuer,
                audience: _jwtSettings.Audience,
                claims: claims,
                expires: DateTime.Now.AddHours(24),
                signingCredentials: credentials
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}
```

登录接口的工作流程如下：首先接收前端发送的登录请求（用户名和密码）；然后在数据库中查找对应的用户记录；若用户不存在或密码错误，返回错误响应；若验证成功，生成JWT令牌并返回给前端，令牌中包含用户名和角色信息；前端将令牌存储在localStorage中，后续请求携带该令牌进行身份验证。

**前端登录页面实现**：

前端登录页面使用Vue 3的Composition API实现，完整组件代码如下：

```vue
<template>
  <div class="login-container">
    <div class="login-card">
      <h1>学生管理系统</h1>
      <form @submit.prevent="handleLogin" class="login-form">
        <div class="form-group">
          <label for="username">用户名</label>
          <input 
            type="text" 
            id="username" 
            v-model="form.username" 
            required
            placeholder="请输入用户名"
          >
        </div>
        <div class="form-group">
          <label for="password">密码</label>
          <input 
            type="password" 
            id="password" 
            v-model="form.password" 
            required
            placeholder="请输入密码"
          >
        </div>
        <button type="submit" class="login-btn" :disabled="loading">
          {{ loading ? '登录中...' : '登录' }}
        </button>
        <p v-if="error" class="error-message">{{ error }}</p>
      </form>
    </div>
  </div>
</template>

<script>
import { ref, reactive } from 'vue';
import { useRouter } from 'vue-router';
import api from '../services/api';

export default {
  name: 'Login',
  setup() {
    const router = useRouter();
    const loading = ref(false);
    const error = ref('');
    const form = reactive({
      username: '',
      password: ''
    });

    const handleLogin = async () => {
      loading.value = true;
      error.value = '';
      
      try {
        const response = await api.post('/Auth/login', form);
        const { token, role, username } = response.data;
        
        // 存储认证信息
        localStorage.setItem('token', token);
        localStorage.setItem('role', role);
        localStorage.setItem('username', username);
        
        // 根据角色跳转到不同页面
        if (role === 'Admin') {
          router.push('/');
        } else {
          router.push('/profile');
        }
      } catch (err) {
        error.value = err.response?.data || '登录失败，请检查用户名和密码';
      } finally {
        loading.value = false;
      }
    };

    return { form, loading, error, handleLogin };
  }
};
</script>

<style scoped>
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #2c5282 0%, #2b6cb0 100%);
}

.login-card {
  background: white;
  padding: 40px;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  width: 100%;
  max-width: 400px;
}

.login-card h1 {
  text-align: center;
  color: #2c5282;
  margin-bottom: 30px;
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: #333;
  font-weight: 500;
}

.form-group input {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 16px;
}

.form-group input:focus {
  outline: none;
  border-color: #2b6cb0;
}

.login-btn {
  width: 100%;
  padding: 14px;
  background: linear-gradient(135deg, #2c5282 0%, #2b6cb0 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.login-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(43, 108, 176, 0.4);
}

.login-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.error-message {
  color: #dc2626;
  text-align: center;
  margin-top: 16px;
  font-size: 14px;
}
</style>
```

**API服务封装**：

前端使用Axios库封装HTTP请求服务，配置请求拦截器和响应拦截器，代码如下：

```javascript
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:5005/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// 请求拦截器，自动携带Token
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
}, error => {
  return Promise.reject(error);
});

// 响应拦截器，处理Token过期
api.interceptors.response.use(response => {
  return response;
}, error => {
  if (error.response?.status === 401) {
    localStorage.removeItem('token');
    localStorage.removeItem('username');
    localStorage.removeItem('role');
    window.location.href = '/login';
  }
  return Promise.reject(error);
});

export default api;
```

**图5-4 登录模块界面效果图**

### 5.4 系统主窗体实现

#### 5.4.1 主界面布局

系统主窗体采用响应式布局设计，左侧为固定宽度的导航栏，右侧为自适应的主内容区。主窗体组件的核心代码结构如下：

```vue
<template>
  <div class="app">
    <!-- 左侧导航栏 -->
    <aside class="sidebar" v-if="isAuthenticated">
      <div class="sidebar-header">
        <h1>学生管理系统</h1>
      </div>
      <nav class="nav-menu">
        <!-- 管理员导航菜单 -->
        <template v-if="userRole === 'Admin'">
          <router-link to="/" class="nav-link" active-class="active">
            <span class="nav-icon">👥</span>
            <span class="nav-text">学生管理</span>
          </router-link>
          <router-link to="/courses" class="nav-link" active-class="active">
            <span class="nav-icon">📚</span>
            <span class="nav-text">课程管理</span>
          </router-link>
          <router-link to="/enrollments" class="nav-link" active-class="active">
            <span class="nav-icon">📊</span>
            <span class="nav-text">成绩管理</span>
          </router-link>
          <router-link to="/logs" class="nav-link" active-class="active">
            <span class="nav-icon">📋</span>
            <span class="nav-text">日志管理</span>
          </router-link>
        </template>
        
        <!-- 学生导航菜单 -->
        <template v-if="userRole === 'Student'">
          <router-link to="/profile" class="nav-link" active-class="active">
            <span class="nav-icon">👤</span>
            <span class="nav-text">个人中心</span>
          </router-link>
          <router-link to="/grades" class="nav-link" active-class="active">
            <span class="nav-icon">📝</span>
            <span class="nav-text">我的成绩</span>
          </router-link>
          <router-link to="/courses" class="nav-link" active-class="active">
            <span class="nav-icon">📚</span>
            <span class="nav-text">我的课程</span>
          </router-link>
        </template>
      </nav>
    </aside>
    
    <!-- 主内容区 -->
    <main class="main-content">
      <router-view />
    </main>
  </div>
</template>

<script>
import { ref, computed } from 'vue';

export default {
  name: 'App',
  setup() {
    const isAuthenticated = computed(() => {
      return !!localStorage.getItem('token');
    });
    
    const userRole = computed(() => {
      return localStorage.getItem('role');
    });
    
    return { isAuthenticated, userRole };
  }
};
</script>

<style scoped>
.app {
  display: flex;
  min-height: 100vh;
}

.sidebar {
  width: 260px;
  background: linear-gradient(180deg, #1a365d 0%, #2c5282 100%);
  color: white;
  display: flex;
  flex-direction: column;
  position: fixed;
  height: 100vh;
  left: 0;
  top: 0;
  z-index: 100;
}

.sidebar-header {
  padding: 24px 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.sidebar-header h1 {
  font-size: 20px;
  font-weight: 700;
  margin: 0;
}

.nav-menu {
  padding: 20px 0;
  flex: 1;
}

.nav-link {
  display: flex;
  align-items: center;
  padding: 16px 24px;
  color: rgba(255, 255, 255, 0.8);
  text-decoration: none;
  transition: all 0.3s ease;
}

.nav-link:hover,
.nav-link.active {
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border-left: 4px solid #63b3ed;
}

.nav-icon {
  font-size: 20px;
  margin-right: 12px;
}

.nav-text {
  font-size: 16px;
  font-weight: 500;
}

.main-content {
  flex: 1;
  margin-left: 260px;
  background: #f8f9fa;
  min-height: 100vh;
}
</style>
```

系统主界面的布局设计采用经典的左右布局模式，左侧为固定导航栏，右侧为内容区域。导航栏采用深蓝色渐变背景，与内容区的浅灰色背景形成鲜明对比，突出层次感。导航菜单项使用图标加文字的形式，增强可读性和用户体验。

系统主界面分为管理员端和学生端两种视图，根据用户角色动态显示不同的导航菜单。管理员可以看到所有管理功能菜单（学生管理、课程管理、成绩管理、日志管理），学生端只显示个人中心相关功能（个人中心、我的成绩、我的课程）。这种设计体现了基于角色的访问控制（RBAC）思想，确保不同角色用户看到的功能菜单与其权限匹配。

**图5-5 管理员端主界面效果图**

**图5-6 学生端主界面效果图**

#### 5.4.2 管理员首页实现

当前学生管理系统的管理员首页直接指向**学生管理页面**，作为系统的主要入口，管理员登录后默认进入该页面。虽然没有专门设计Dashboard组件，但学生管理页面作为管理员的核心工作区域，提供了完整的学生信息管理功能，同时系统顶部导航栏包含了所有管理功能的入口。

##### 核心功能

管理员首页（学生管理页面）主要包含以下核心功能：

1. **学生信息管理**
   - 学生列表展示，支持分页和搜索
   - 添加新学生信息
   - 编辑现有学生信息
   - 删除学生记录
   - 查看学生详细信息和选课情况

2. **系统导航**
   - 左侧导航栏包含所有管理模块入口
   - 支持在不同管理模块间快速切换
   - 显示当前登录用户信息
   - 提供退出登录功能

3. **权限控制**
   - 基于JWT的身份验证
   - 角色权限管理（仅管理员可访问）
   - 路由守卫确保安全访问

##### 实现细节

**路由配置**

管理员首页通过Vue Router配置为系统默认路由：

```javascript
// 管理员路由
{
  path: '/',
  name: 'StudentManagement',
  component: StudentManagement,
  meta: { requiresAuth: true, roles: ['Admin'] }
}
```

**核心组件结构**

管理员首页的核心组件是`StudentManagement.vue`，其主要结构包括：

- **导航栏**：提供系统功能入口
- **学生列表**：展示所有学生信息
- **操作按钮**：添加、编辑、删除学生
- **模态框**：用于添加和编辑学生信息
- **学生课程模态框**：查看学生选课和成绩

**核心逻辑**

1. **页面加载**：调用`getStudents`接口获取所有学生信息
2. **数据展示**：以表格形式展示学生列表，包含ID、姓名、年龄、邮箱等信息
3. **学生操作**：
   - 点击"添加"按钮打开添加学生模态框
   - 点击"编辑"按钮打开编辑学生模态框，填充现有数据
   - 点击"删除"按钮执行删除操作，有确认提示
   - 点击"查看课程"按钮打开学生课程模态框
4. **表单验证**：确保学生信息的完整性和格式正确性
5. **状态管理**：使用Vue 3 Composition API管理组件状态

##### 页面设计

1. **布局设计**
   - 采用左侧导航栏+右侧内容区的经典管理系统布局
   - 导航栏包含所有管理模块入口
   - 内容区上方有操作按钮和搜索框
   - 学生列表采用表格形式，清晰展示各项信息

2. **色彩设计**
   - 整体采用蓝色主题，符合现代管理系统审美
   - 按钮和交互元素使用鲜明的蓝色，提高可识别性
   - 表格行交替颜色，增强可读性
   - 模态框使用半透明背景，突出当前操作

3. **交互设计**
   - 所有操作有明确的视觉反馈
   - 添加/编辑学生时使用模态框，避免页面跳转
   - 删除操作有确认提示，防止误操作
   - 表格支持滚动，适应大量数据展示

##### 功能扩展建议

虽然当前系统的管理员首页已经满足基本的学生管理需求，但可以考虑在未来版本中添加以下功能，使其更符合传统Dashboard的设计理念：

1. **数据统计卡片**：展示学生总数、课程总数、选课记录数等核心指标
2. **快速功能入口**：提供直达各管理模块的快捷按钮
3. **最近操作日志**：展示系统最近的操作记录
4. **系统状态监控**：显示系统运行状态和关键性能指标

#### 5.4.3 学生页面实现

学生端页面是学生用户访问系统的核心界面，提供了个人信息管理、课程查询和成绩查询等功能。学生登录后默认进入个人中心页面，通过左侧导航栏可以切换到不同功能页面。

##### 核心功能

学生页面主要包含以下核心功能模块：

1. **个人中心**
   - 展示学生基本信息（姓名、年龄、邮箱）
   - 显示学生GPA（平均绩点）
   - 提供修改个人信息的功能

2. **我的成绩**
   - 展示所有已修课程的成绩
   - 按课程名称、成绩等级等条件筛选
   - 计算并显示总学分和GPA
   - 提供成绩详情查看功能

3. **我的课程**
   - 展示学生当前选修的所有课程
   - 显示课程名称、任课教师、学分等信息
   - 提供课程详情查看功能

4. **系统导航**
   - 左侧导航栏包含所有学生功能入口
   - 支持在不同功能模块间快速切换
   - 显示当前登录用户信息
   - 提供退出登录功能

##### 实现细节

**路由配置**

学生端页面通过Vue Router配置，核心路由如下：

```javascript
// 学生路由
{
  path: '/profile',
  name: 'StudentProfile',
  component: StudentProfile,
  meta: { requiresAuth: true, roles: ['Student'] }
},
{
  path: '/my-courses',
  name: 'MyCourses',
  component: () => import('../components/MyCourses.vue'),
  meta: { requiresAuth: true, roles: ['Student'] }
},
{
  path: '/my-grades',
  name: 'MyGrades',
  component: () => import('../components/MyGrades.vue'),
  meta: { requiresAuth: true, roles: ['Student'] }
}
```

**核心组件**

1. **StudentProfile.vue**：学生个人中心组件，展示学生基本信息和GPA
2. **MyGrades.vue**：我的成绩组件，展示学生所有课程成绩
3. **MyCourses.vue**：我的课程组件，展示学生选修的课程

**核心逻辑**

1. **个人中心**：
   - 页面加载时调用`getStudentInfo`接口获取学生基本信息
   - 调用`getMyGrades`接口获取成绩数据，计算GPA
   - 提供编辑功能，修改学生基本信息

2. **我的成绩**：
   - 页面加载时调用`getMyGrades`接口获取成绩数据
   - 自动计算总学分和GPA
   - 支持按课程名称搜索
   - 展示课程详细信息（名称、任课教师、描述、学分）

3. **我的课程**：
   - 页面加载时调用`getMyCourses`接口获取选课数据
   - 展示课程基本信息
   - 支持按课程名称搜索

##### 页面设计

1. **布局设计**
   - 采用与管理员端一致的左侧导航栏+右侧内容区布局
   - 导航栏显示学生专属功能菜单
   - 内容区采用卡片式设计，信息层次清晰

2. **色彩设计**
   - 延续系统统一的蓝色主题
   - 成绩区域使用不同颜色区分不同成绩等级
   - GPA显示区域采用突出设计，便于学生快速查看

3. **交互设计**
   - 平滑的页面切换动画
   - 悬停效果增强用户体验
   - 响应式设计，适配不同屏幕尺寸

##### 功能亮点

1. **GPA自动计算**：系统根据学生成绩自动计算GPA，无需手动计算
2. **成绩可视化**：通过颜色区分不同成绩等级，直观清晰
3. **课程详情展示**：提供完整的课程信息，包括描述和任课教师
4. **统一的用户体验**：与管理员端保持一致的设计风格，降低学习成本
5. **响应式设计**：适配不同设备，提高系统可用性

**图5-7 学生个人中心效果图**
**图5-8 我的成绩页面效果图**
**图5-9 我的课程页面效果图**

### 5.5 学生管理模块实现

学生管理模块是系统的核心功能之一，实现学生信息的增删改查功能。前端组件StudentManagement.vue实现了完整的CRUD操作界面，包括学生列表展示、添加学生表单、编辑学生表单和删除确认等功能。

**5.5.1 学生列表展示**

学生列表采用表格形式展示，支持分页和搜索功能。表格组件支持以下功能：显示所有学生的基本信息（ID、姓名、年龄、邮箱）；显示操作按钮（编辑、查看课程、删除）；支持响应式布局，小屏幕下显示水平滚动条。

学生列表组件的完整模板代码如下：

```vue
<template>
  <div class="student-management">
    <div class="content-grid">
      <!-- 学生表单区域 -->
      <div class="form-card">
        <div class="card-header">
          <h2>{{ editing ? '编辑学生' : '添加学生' }}</h2>
        </div>
        <div class="card-body">
          <form @submit.prevent="handleSubmit" class="student-form">
            <div class="form-row">
              <div class="form-group">
                <label for="id">ID</label>
                <div class="input-wrapper">
                  <input 
                    type="number" 
                    id="id" 
                    v-model="form.id" 
                    required
                    placeholder="请输入学生ID"
                    min="1000"
                  >
                </div>
              </div>
              <div class="form-group">
                <label for="name">姓名</label>
                <div class="input-wrapper">
                  <input 
                    type="text" 
                    id="name" 
                    v-model="form.name" 
                    required
                    placeholder="请输入学生姓名"
                  >
                </div>
              </div>
            </div>
            <div class="form-row">
              <div class="form-group">
                <label for="age">年龄</label>
                <div class="input-wrapper">
                  <input 
                    type="number" 
                    id="age" 
                    v-model="form.age" 
                    required
                    placeholder="请输入学生年龄"
                    min="1"
                    max="100"
                  >
                </div>
              </div>
              <div class="form-group">
                <label for="email">邮箱</label>
                <div class="input-wrapper">
                  <input 
                    type="email" 
                    id="email" 
                    v-model="form.email" 
                    required
                    placeholder="请输入学生邮箱"
                  >
                </div>
              </div>
            </div>
            <div class="form-actions">
              <button type="submit" class="btn btn-primary">
                {{ editing ? '更新' : '添加' }}
              </button>
              <button 
                type="button" 
                class="btn btn-secondary" 
                @click="resetForm"
                v-if="editing"
              >
                取消
              </button>
            </div>
          </form>
        </div>
      </div>
      
      <!-- 学生列表区域 -->
      <div class="list-card">
        <div class="card-header">
          <h2>学生列表</h2>
          <div class="card-stats">
            <span class="stat-item">
              <span class="stat-icon">👥</span>
              <span class="stat-value">{{ students.length }}</span>
              <span class="stat-label">学生总数</span>
            </span>
          </div>
        </div>
        <div class="card-body">
          <div class="table-wrapper">
            <table class="student-table">
              <thead>
                <tr>
                  <th class="table-th">ID</th>
                  <th class="table-th">姓名</th>
                  <th class="table-th">年龄</th>
                  <th class="table-th">邮箱</th>
                  <th class="table-th table-th-actions">操作</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="student in students" :key="student.id" class="table-tr">
                  <td class="table-td">{{ student.id }}</td>
                  <td class="table-td">{{ student.name }}</td>
                  <td class="table-td">{{ student.age }}</td>
                  <td class="table-td">{{ student.email }}</td>
                  <td class="table-td table-td-actions">
                    <div class="action-buttons">
                      <button 
                        class="btn btn-edit" 
                        @click="editStudent(student)"
                        title="编辑"
                      >
                        编辑
                      </button>
                      <button 
                        class="btn btn-view" 
                        @click="viewStudentCourses(student.id)"
                        title="查看课程"
                      >
                        查看课程
                      </button>
                      <button 
                        class="btn btn-delete" 
                        @click="deleteStudent(student.id)"
                        title="删除"
                      >
                        删除
                      </button>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 学生课程模态框 -->
    <div v-if="showCoursesModal" class="modal-overlay" @click="showCoursesModal = false">
      <div class="modal-content" @click.stop>
        <div class="modal-header">
          <h2>{{ selectedStudentName }}的课程</h2>
          <button class="modal-close" @click="showCoursesModal = false">×</button>
        </div>
        <div class="modal-body">
          <div v-if="coursesLoading" class="loading-state">
            <div class="loading-spinner"></div>
            <div class="loading-text">加载课程中...</div>
          </div>
          <div v-else-if="studentCourses.length === 0" class="empty-state">
            <div class="empty-icon"></div>
            <div class="empty-text">暂无课程信息</div>
          </div>
          <table v-else class="student-courses-table">
            <thead>
              <tr>
                <th>课程名称</th>
                <th>课程代码</th>
                <th>教师</th>
                <th>学分</th>
                <th>成绩</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="enrollment in studentCourses" :key="enrollment.id">
                <td>{{ enrollment.course?.title || '未知课程' }}</td>
                <td>{{ enrollment.course?.code || '未知代码' }}</td>
                <td>{{ enrollment.course?.instructor || '未知教师' }}</td>
                <td>{{ enrollment.course?.credits || 0 }}</td>
                <td>{{ enrollment.grade !== null ? enrollment.grade : '未评分' }}</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" @click="showCoursesModal = false">关闭</button>
        </div>
      </div>
    </div>
  </div>
</template>
```

**5.5.2 学生信息编辑**

学生管理模块的交互逻辑使用Vue 3的Composition API实现，核心方法包括：

```javascript
import { ref, reactive, onMounted } from 'vue';
import { studentService, enrollmentService } from '../services/api';

export default {
  name: 'StudentManagement',
  data() {
    return {
      students: [],
      form: {
        id: null,
        name: '',
        age: '',
        email: ''
      },
      editing: false,
      showCoursesModal: false,
      selectedStudentId: null,
      selectedStudentName: '',
      studentCourses: [],
      coursesLoading: false
    };
  },
  mounted() {
    this.fetchStudents();
  },
  methods: {
    async fetchStudents() {
      try {
        const response = await studentService.getAll();
        console.log('获取到的学生数据:', response.data);
        this.students = response.data;
      } catch (error) {
        console.error('获取学生列表失败:', error);
        alert('获取学生列表失败');
      }
    },
    
    async handleSubmit() {
      try {
        if (this.editing) {
          await studentService.update(this.form.id, this.form);
          alert('学生更新成功');
        } else {
          await studentService.create(this.form);
          alert('学生添加成功');
        }
        this.fetchStudents();
        this.resetForm();
      } catch (error) {
        console.error('操作失败:', error);
        alert('操作失败: ' + (error.response?.data?.detail || error.message || '未知错误'));
      }
    },
    
    editStudent(student) {
      console.log('开始编辑学生:', student);
      this.editing = true;
      this.form = {
        id: student.id,
        name: student.name,
        age: student.age,
        email: student.email
      };
      console.log('编辑状态设置完成:', this.form, 'editing:', this.editing);
    },
    
    async deleteStudent(id) {
      if (confirm('确定要删除这个学生吗?')) {
        try {
          await studentService.delete(id);
          alert('学生删除成功');
          this.fetchStudents();
        } catch (error) {
          console.error('删除失败:', error);
          alert('删除失败');
        }
      }
    },
    
    resetForm() {
      this.editing = false;
      this.form = {
        id: null,
        name: '',
        age: '',
        email: ''
      };
    },
    
    async viewStudentCourses(studentId) {
      try {
        this.selectedStudentId = studentId;
        this.selectedStudentName = this.students.find(s => s.id === studentId)?.name || '未知学生';
        this.coursesLoading = true;
        this.showCoursesModal = true;
        
        const response = await enrollmentService.getByStudentId(studentId);
        this.studentCourses = response.data;
      } catch (error) {
        console.error('获取学生课程失败:', error);
        alert('获取学生课程失败');
      } finally {
        this.coursesLoading = false;
      }
    }
  }
};
```

**5.5.3 后端API实现**

后端学生管理API控制器实现了完整的RESTful接口，代码如下：

```csharp
using Backend.Data;
using Backend.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace Backend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class StudentController : ControllerBase
    {
        private readonly SchoolContext _context;
        private readonly ILogger<StudentController> _logger;

        public StudentController(SchoolContext context, ILogger<StudentController> logger)
        {
            _context = context;
            _logger = logger;
        }

        // 获取所有学生
        [HttpGet]
        [Authorize(Roles = "Admin")]
        public async Task<ActionResult<IEnumerable<Student>>> GetStudents()
        {
            _logger.LogInformation("管理员获取所有学生列表");
            var students = await _context.Students.ToListAsync();
            _logger.LogInformation("成功获取 {Count} 名学生", students.Count);
            return students;
        }

        // 获取单个学生
        [HttpGet("{id}")]
        [Authorize]
        public async Task<ActionResult<Student>> GetStudent(int id)
        {
            var student = await _context.Students.FindAsync(id);

            if (student == null)
            {
                return NotFound();
            }

            var username = User.Identity?.Name;
            var userRole = User.FindFirst(System.Security.Claims.ClaimTypes.Role)?.Value;

            // 学生只能获取自己的信息
            if (userRole == "Student")
            {
                if (!int.TryParse(username, out int currentStudentId) || currentStudentId != id)
                {
                    return Forbid("您没有权限访问其他学生的信息");
                }
            }

            return student;
        }

        // 添加学生
        [HttpPost]
        [Authorize(Roles = "Admin")]
        public async Task<ActionResult<Student>> PostStudent(Student student)
        {
            _logger.LogInformation("管理员添加学生: {StudentName}", student.Name);
            _context.Students.Add(student);
            await _context.SaveChangesAsync();
            _logger.LogInformation("成功添加学生: {StudentName} (ID: {StudentId})", student.Name, student.Id);
            return CreatedAtAction(nameof(GetStudent), new { id = student.Id }, student);
        }

        // 更新学生信息
        [HttpPut("{id}")]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> PutStudent(int id, Student student)
        {
            // 检查学生是否存在
            var existingStudent = await _context.Students.FindAsync(id);
            if (existingStudent == null)
            {
                _logger.LogWarning("尝试更新不存在的学生 (ID: {StudentId})", id);
                return NotFound();
            }

            // 如果要修改ID，先删除旧记录再创建新记录
            if (id != student.Id)
            {
                _logger.LogInformation("管理员修改学生ID: 从 {OldId} 到 {NewId}", id, student.Id);
                
                _context.Students.Remove(existingStudent);
                _context.Students.Add(student);
            }
            else
            {
                // 更新现有学生记录的属性
                _context.Entry(existingStudent).CurrentValues.SetValues(student);
            }

            try
            {
                await _context.SaveChangesAsync();
                _logger.LogInformation("成功更新学生信息: {StudentName} (ID: {StudentId})", student.Name, student.Id);
            }
            catch (DbUpdateConcurrencyException)
            {
                _logger.LogError("更新学生信息并发冲突: {StudentName} (ID: {StudentId})", student.Name, student.Id);
                throw;
            }

            return NoContent();
        }

        // 删除学生
        [HttpDelete("{id}")]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> DeleteStudent(int id)
        {
            _logger.LogInformation("管理员删除学生 (ID: {StudentId})", id);
            var student = await _context.Students.FindAsync(id);
            if (student == null)
            {
                _logger.LogWarning("尝试删除不存在的学生 (ID: {StudentId})", id);
                return NotFound();
            }

            _context.Students.Remove(student);
            await _context.SaveChangesAsync();
            _logger.LogInformation("成功删除学生: {StudentName} (ID: {StudentId})", student.Name, student.Id);
            return NoContent();
        }
    }
}
```

学生管理模块的API设计遵循RESTful规范，使用HTTP方法语义表达操作类型：GET请求用于获取数据，POST请求用于创建数据，PUT请求用于更新数据，DELETE请求用于删除数据。每个接口都配置了相应的权限要求，确保只有授权用户才能访问。

**图5-7 学生管理模块界面效果图**

---

## 六、个人心得与总结

通过本次学生管理系统的开发实践，我深入学习了前后端分离架构的设计理念和实现方法，掌握了.NET Web API后端开发、Vue.js前端开发以及EF Core数据库操作等核心技术。在项目开发过程中，我遇到并解决了许多技术难题，积累了宝贵的实践经验。

在技术学习方面，我系统掌握了.NET Core框架的核心功能。首先是依赖注入容器配置，通过Autofac实现了服务注册和依赖解析，理解了控制反转（IoC）和依赖倒置（DIP）原则的实际应用；其次是中间件管道构建，学会了配置认证、授权、CORS等中间件，构建完整的HTTP请求处理流水线；最后是API控制器开发，掌握了RESTful接口设计规范、参数绑定、模型验证等技能。

EF Core的Code First模式让我深刻理解了面向对象设计与数据库设计的映射关系。通过实体模型配置可以自动生成数据库表结构，大大简化了数据库开发工作。在实践中，我学会了使用Fluent API配置实体关系、处理主键生成策略、配置种子数据等技能。EF Core的导航属性和延迟加载功能使得数据访问代码更加简洁，同时也需要关注性能问题，避免N+1查询问题。

Vue 3的Composition API和响应式系统让我对现代前端开发有了更深入的认识。组合式API将相关逻辑组织在一起，提高了代码的可维护性和复用性；响应式系统自动追踪数据变化并更新视图，减少了手动DOM操作；组件化开发思想提高了代码的模块化程度，便于团队协作开发。

在架构设计方面，我学会了运用依赖注入模式实现组件解耦。通过接口抽象降低模块间的耦合度，使得代码更容易测试和维护。Autofac容器的使用让我理解了依赖注入的三种生命周期（瞬时、作用域、单例），以及如何根据服务特性选择合适的生命周期。

前后端分离架构的设计让我认识到前后端协作的重要性。通过RESTful API进行数据交互，前后端可以独立开发、独立部署，提高了开发效率和系统可维护性。同时，API文档的编写和接口规范的一致性也成为了团队协作的关键。

在问题解决方面，我培养了系统分析和问题定位的能力。在开发过程中，我遇到了EF Core实体跟踪冲突、跨域请求失败、API参数传递错误等问题。通过阅读错误日志、使用调试工具追踪代码执行流程、分析问题产生的根本原因，我逐步学会了系统化的排错方法。这些经验对我今后的项目开发工作具有重要的指导意义。

具体来说，在解决EF Core实体跟踪冲突问题时，我学会了使用`Entry().CurrentValues.SetValues()`方法更新现有实体属性，而不是直接设置`State = Modified`，从而避免了实体跟踪冲突。在解决跨域请求问题时，我学会了正确配置CORS策略，允许前端应用访问后端API。在解决API参数传递问题时，我学会了检查前后端数据类型的一致性，确保数据正确传输。

在不足与改进方面，本系统还存在一些可以优化的地方：第一，缺少数据导入导出功能，可以添加Excel文件导入和成绩报表导出功能，提高数据管理效率；第二，前端界面可以进一步优化，增加更多的交互效果和动画，提升用户体验；第三，系统安全方面可以加强，实现更细粒度的权限控制和操作审计，防范恶意操作；第四，性能优化方面，可以添加数据库索引、优化查询语句、实现接口缓存等；第五，测试方面，可以添加单元测试和集成测试，确保代码质量和功能正确性。

通过本次实验，我不仅提高了编程技能，更重要的是培养了工程化开发意识和团队协作能力。我学会了使用Git进行版本控制，编写规范的代码注释和文档，使用敏捷开发方法进行项目管理。这些软技能对于今后的职业发展具有重要意义。

在今后的学习中，我将继续深入研究前后端开发技术，关注行业发展趋势，学习新的框架和工具。同时，我也会注重基础知识的巩固和算法能力的提升，为今后从事软件开发工作打下坚实基础。本次实验虽然告一段落，但我的学习之路才刚刚开始。

---

**图6-1 项目整体运行效果图**
