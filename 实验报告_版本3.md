# 实验 4 前后端分离项目（.NET Web API + 前端框架 + EF Code First + Autofac IOC）实验报告

## 一、 实验概述

### 实验任务与要求
本次实验基于实验 1-3 的技术积累，实现一个前后端分离的学生管理系统。实验 1 实现了基于 EF Code First 的数据访问层，实验 2 实现了 .NET Web MVC 5 项目，实验 3 在此基础上实现前后端分离架构。本次实验的核心任务包括：

1. 掌握前后端分离架构的核心思想与实现方式
2. 熟练使用 .NET Web API 构建 RESTful 接口
3. 掌握 EF Code First 开发模式
4. 理解并应用 Autofac IOC 容器实现依赖注入
5. 学会使用 Vue.js 与后端 API 进行交互
6. 实现学生管理、课程管理、成绩管理等核心功能

### 实验核心技术点汇总
- **后端技术**：.NET 6 Web API、EF Core Code First、Autofac IOC、JWT Token 认证
- **前端技术**：Vue.js 3、Vue Router、Axios、Element Plus
- **数据库技术**：SQL Server 2019
- **开发工具**：Visual Studio 2022、VS Code、Postman

### 实验环境准备
- **后端环境**：
  - 安装 .NET 6 SDK 和 Visual Studio 2022
  - 创建 .NET Web API 项目
  - 安装 EF Core 和 Autofac 依赖包
  - 配置数据库连接字符串

- **前端环境**：
  - 安装 Node.js 16.x
  - 使用 Vite 创建 Vue.js 3 项目
  - 安装 Element Plus、Axios 等依赖包
  - 配置项目基础结构

- **数据库环境**：
  - 安装 SQL Server 2019
  - 创建数据库实例
  - 配置数据库连接权限

### 项目整体需求梳理
本项目是一个学生管理系统，主要功能包括：

1. **用户认证**：
   - 管理员登录
   - 学生登录
   - Token 生成与验证

2. **学生管理**：
   - 学生信息的增删改查
   - 学生列表展示
   - 学生信息详情查看

3. **课程管理**：
   - 课程信息的增删改查
   - 课程列表展示
   - 课程信息详情查看

4. **成绩管理**：
   - 学生成绩的增删改查
   - 成绩列表展示
   - 成绩信息详情查看

5. **学生个人中心**：
   - 学生查看个人信息
   - 学生查看自己的课程
   - 学生查看自己的成绩

## 二、 项目架构设计与规划

### 前后端分离架构核心原理
前后端分离架构是指将前端和后端作为独立的应用开发，通过 RESTful API 进行通信。前端负责用户界面和交互逻辑，后端负责数据处理和业务逻辑。这种架构的核心原理包括：

1. **关注点分离**：前端关注用户体验，后端关注业务逻辑和数据处理
2. **API 驱动开发**：前后端通过 API 进行通信，API 定义了前后端的交互契约
3. **独立部署**：前后端可以独立部署和迭代，提高开发效率
4. **技术栈解耦**：前后端可以使用不同的技术栈，便于技术选型和团队协作

### 后端项目模块化设计
后端采用分层架构设计，主要包括以下模块：

```
├── Model 层      # 数据实体类，对应业务数据表
│   ├── Student.cs        # 学生实体
│   ├── Course.cs         # 课程实体
│   ├── Enrollment.cs     # 成绩实体
│   └── User.cs           # 用户实体

├── DAL 层        # 数据访问层，负责与数据库交互
│   └── SchoolContext.cs  # DbContext 配置，实现 EF Code First

├── BLL 层        # 业务逻辑层，封装核心业务逻辑
│   ├── Interfaces/       # 业务接口定义
│   └── Services/         # 业务接口实现

├── API 层        # 接口服务层，提供 RESTful API
│   ├── Controllers/      # API 控制器
│   └── Filters/          # 过滤器，如认证授权过滤器

├── Common 层     # 公共工具类
│   ├── JwtHelper.cs      # JWT 工具类
│   └── ResponseHelper.cs # 统一返回格式工具类
```

### 前端项目模块化设计
前端采用组件化开发，主要包括以下模块：

```
├── 页面模块      # 业务页面
│   ├── Login.vue                # 登录页面
│   ├── Layout.vue               # 布局页面
│   ├── Admin/                   # 管理员页面
│   │   ├── CourseManagement.vue    # 课程管理
│   │   ├── EnrollmentManagement.vue # 成绩管理
│   │   └── StudentManagement.vue   # 学生管理
│   └── Student/                 # 学生页面
│       ├── MyCourses.vue        # 我的课程
│       ├── MyGrades.vue         # 我的成绩
│       └── StudentProfile.vue   # 个人信息

├── 组件模块      # 可复用组件
│   ├── Common/                  # 公共组件
│   │   ├── Header.vue               # 页头组件
│   │   └── Sidebar.vue             # 侧边栏组件
│   └── Form/                    # 表单组件
│       ├── StudentForm.vue          # 学生表单
│       └── CourseForm.vue           # 课程表单

├── 请求模块      # API 请求封装
│   └── request.js               # Axios 封装与拦截器配置

├── 工具模块      # 公共工具函数
│   └── utils.js                 # 工具函数

└── 配置模块      # 全局配置
    ├── router/                  # 路由配置
    │   └── index.js
    └── main.js                  # 应用入口
```

### 核心技术对接方案

#### EF Code First 数据流转
1. **实体定义**：定义实体类和关系，使用数据注解配置
2. **DbContext 配置**：创建 DbContext 类，配置数据库连接和实体映射
3. **数据迁移**：执行数据迁移生成数据库表结构
4. **数据操作**：通过 DbContext 进行 CRUD 操作

#### Autofac 依赖注入
1. **容器初始化**：在 Program.cs 中配置 Autofac 容器
2. **服务注册**：注册 DbContext、业务逻辑层服务等
3. **构造函数注入**：在控制器和服务中通过构造函数注入依赖
4. **运行时解析**：Autofac 容器在运行时解析依赖，创建对象实例

#### 前后端接口联调
1. **API 设计**：后端设计 RESTful API，定义请求和响应格式
2. **请求封装**：前端封装 Axios 请求，添加 Token 和错误处理
3. **跨域配置**：后端配置 CORS 中间件，允许前端访问
4. **数据绑定**：前端调用 API 获取数据，绑定到页面组件

## 三、 后端核心模块实现与配置

### 数据持久化模块（EF Code First）

#### 实体模型设计与构建
```csharp
// Student.cs
public class Student
{
    [Key]
    public int Id { get; set; }
    [Required]
    [StringLength(50)]
    public string Name { get; set; }
    public int Age { get; set; }
    [Required]
    [EmailAddress]
    public string Email { get; set; }
    
    public ICollection<Enrollment> Enrollments { get; set; }
}

// Course.cs
public class Course
{
    [Key]
    public int Id { get; set; }
    [Required]
    [StringLength(100)]
    public string Title { get; set; }
    public int Credits { get; set; }
    
    public ICollection<Enrollment> Enrollments { get; set; }
}

// Enrollment.cs
public class Enrollment
{
    [Key]
    public int Id { get; set; }
    public int StudentId { get; set; }
    public int CourseId { get; set; }
    public int Grade { get; set; }
    
    public Student Student { get; set; }
    public Course Course { get; set; }
}
```

#### DbContext 配置与数据库初始化
```csharp
public class SchoolContext : DbContext
{
    public SchoolContext(DbContextOptions<SchoolContext> options) : base(options)
    { }
    
    public DbSet<Student> Students { get; set; }
    public DbSet<Course> Courses { get; set; }
    public DbSet<Enrollment> Enrollments { get; set; }
    public DbSet<User> Users { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // 配置种子数据
        modelBuilder.Entity<Student>().HasData(
            new Student { Id = 1001, Name = "张三", Age = 20, Email = "zhangsan@example.com" },
            new Student { Id = 1002, Name = "李四", Age = 21, Email = "lisi@example.com" },
            new Student { Id = 1003, Name = "王五", Age = 22, Email = "wangwu@example.com" },
            new Student { Id = 1004, Name = "张艳艳", Age = 20, Email = "zhangyanyan@example.com" }
        );
        
        // 其他种子数据配置...
    }
}
```

#### 数据迁移与数据库生成
通过 `EnsureCreated()` 方法初始化数据库：
```csharp
// Program.cs
using (var scope = app.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<SchoolContext>();
    context.Database.EnsureCreated();
}
```

### 依赖注入模块（Autofac）

#### Autofac 容器配置
```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

// 配置 Autofac
builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());
builder.Host.ConfigureContainer<ContainerBuilder>(builder =>
{
    // 注册 DbContext
    builder.RegisterType<SchoolContext>().AsSelf().InstancePerLifetimeScope();
    
    // 注册控制器
    builder.RegisterControllers(typeof(Program).Assembly);
    
    // 注册业务逻辑层服务
    // builder.RegisterType<StudentService>().As<IStudentService>().InstancePerLifetimeScope();
    // 其他服务注册...
});
```

#### 控制器依赖注入
```csharp
// StudentController.cs
[ApiController]
[Route("api/[controller]")]
public class StudentController : ControllerBase
{
    private readonly SchoolContext _context;
    
    // 构造函数注入
    public StudentController(SchoolContext context)
    {
        _context = context;
    }
    
    // 接口实现...
}
```

### 接口服务模块（.NET Web API）

#### 控制器设计与接口实现
```csharp
// StudentController.cs
[ApiController]
[Route("api/[controller]")]
public class StudentController : ControllerBase
{
    private readonly SchoolContext _context;
    
    public StudentController(SchoolContext context)
    {
        _context = context;
    }
    
    // GET: api/students
    [HttpGet]
    public async Task<ActionResult<IEnumerable<Student>>> GetStudents()
    {
        return await _context.Students.ToListAsync();
    }
    
    // GET: api/students/{id}
    [HttpGet("{id}")]
    public async Task<ActionResult<Student>> GetStudent(int id)
    {
        var student = await _context.Students.FindAsync(id);
        if (student == null) {
            return NotFound();
        }
        return student;
    }
    
    // POST: api/students
    [HttpPost]
    public async Task<ActionResult<Student>> PostStudent(Student student)
    {
        _context.Students.Add(student);
        await _context.SaveChangesAsync();
        return CreatedAtAction(nameof(GetStudent), new { id = student.Id }, student);
    }
    
    // PUT: api/students/{id}
    [HttpPut("{id}")]
    public async Task<IActionResult> PutStudent(int id, Student student)
    {
        if (id != student.Id) {
            return BadRequest();
        }
        
        _context.Entry(student).State = EntityState.Modified;
        
        try {
            await _context.SaveChangesAsync();
        } catch (DbUpdateConcurrencyException) {
            if (!StudentExists(id)) {
                return NotFound();
            } else {
                throw;
            }
        }
        
        return NoContent();
    }
    
    // DELETE: api/students/{id}
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteStudent(int id)
    {
        var student = await _context.Students.FindAsync(id);
        if (student == null) {
            return NotFound();
        }
        
        _context.Students.Remove(student);
        await _context.SaveChangesAsync();
        
        return NoContent();
    }
    
    private bool StudentExists(int id)
    {
        return _context.Students.Any(e => e.Id == id);
    }
}
```

#### 统一返回格式封装
```csharp
// ResponseHelper.cs
public class ApiResponse<T>
{
    public int Code { get; set; }
    public string Message { get; set; }
    public T Data { get; set; }
    
    public ApiResponse(int code, string message, T data)
    {
        Code = code;
        Message = message;
        Data = data;
    }
    
    public static ApiResponse<T> Success(T data, string message = "操作成功")
    {
        return new ApiResponse<T>(200, message, data);
    }
    
    public static ApiResponse<T> Error(string message = "操作失败", int code = 500)
    {
        return new ApiResponse<T>(code, message, default);
    }
}
```

## 四、 前端核心模块实现与联调

### 基础支撑模块

#### 项目初始化与全局配置
1. 使用 Vite 创建 Vue.js 3 项目：
   ```bash
   npm create vite@latest frontend -- --template vue
   ```

2. 安装必要依赖包：
   ```bash
   npm install element-plus axios vue-router
   ```

#### Axios 请求封装与拦截器配置
```javascript
// request.js
import axios from 'axios'

const service = axios.create({
  baseURL: 'https://localhost:7277/api',
  timeout: 5000
})

// 请求拦截器
service.interceptors.request.use(
  config => {
    // 添加 Token
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => {
    console.log(error)
    return Promise.reject(error)
  }
)

// 响应拦截器
service.interceptors.response.use(
  response => {
    const res = response.data
    return res
  },
  error => {
    console.log('err' + error)
    return Promise.reject(error)
  }
)

export default service
```

#### 路由配置
```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import Layout from '../views/Layout.vue'
import Login from '../views/Login.vue'

const routes = [
  {
    path: '/',
    name: 'Layout',
    component: Layout,
    redirect: '/student/profile',
    children: [
      // 学生页面
      {
        path: '/student/profile',
        name: 'StudentProfile',
        component: () => import('../views/Student/StudentProfile.vue')
      },
      {
        path: '/student/courses',
        name: 'MyCourses',
        component: () => import('../views/Student/MyCourses.vue')
      },
      {
        path: '/student/grades',
        name: 'MyGrades',
        component: () => import('../views/Student/MyGrades.vue')
      },
      // 管理员页面
      {
        path: '/admin/students',
        name: 'StudentManagement',
        component: () => import('../views/Admin/StudentManagement.vue')
      },
      {
        path: '/admin/courses',
        name: 'CourseManagement',
        component: () => import('../views/Admin/CourseManagement.vue')
      },
      {
        path: '/admin/enrollments',
        name: 'EnrollmentManagement',
        component: () => import('../views/Admin/EnrollmentManagement.vue')
      }
    ]
  },
  {
    path: '/login',
    name: 'Login',
    component: Login
  }
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router
```

### 业务页面模块

#### 学生管理页面
```vue
<template>
  <div class="student-list">
    <el-card shadow="hover">
      <template #header>
        <div class="card-header">
          <span>学生管理</span>
          <el-button type="primary" @click="handleAdd">新增学生</el-button>
        </div>
      </template>
      
      <el-table :data="students" stripe>
        <el-table-column prop="id" label="学生ID" width="100"></el-table-column>
        <el-table-column prop="name" label="姓名" width="120"></el-table-column>
        <el-table-column prop="age" label="年龄" width="80"></el-table-column>
        <el-table-column prop="email" label="邮箱"></el-table-column>
        <el-table-column label="操作" width="200">
          <template #default="scope">
            <el-button type="primary" size="small" @click="handleEdit(scope.row)">编辑</el-button>
            <el-button type="danger" size="small" @click="handleDelete(scope.row.id)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
    </el-card>
    
    <!-- 新增/编辑对话框 -->
    <el-dialog v-model="dialogVisible" title="{{ dialogTitle }}" width="500px">
      <el-form :model="form" label-width="80px">
        <el-form-item label="学生ID">
          <el-input v-model="form.id" :disabled="isEdit" placeholder="请输入学生ID"></el-input>
        </el-form-item>
        <el-form-item label="姓名">
          <el-input v-model="form.name" placeholder="请输入姓名"></el-input>
        </el-form-item>
        <el-form-item label="年龄">
          <el-input v-model.number="form.age" placeholder="请输入年龄"></el-input>
        </el-form-item>
        <el-form-item label="邮箱">
          <el-input v-model="form.email" placeholder="请输入邮箱"></el-input>
        </el-form-item>
      </el-form>
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="dialogVisible = false">取消</el-button>
          <el-button type="primary" @click="handleSubmit">确定</el-button>
        </span>
      </template>
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import request from '@/utils/request'

const students = ref([])
const dialogVisible = ref(false)
const isEdit = ref(false)
const dialogTitle = ref('新增学生')
const form = ref({
  id: '',
  name: '',
  age: '',
  email: ''
})

// 获取学生列表
const getStudents = async () => {
  try {
    const res = await request.get('/students')
    students.value = res
  } catch (error) {
    console.error('获取学生列表失败:', error)
  }
}

// 新增学生
const handleAdd = () => {
  isEdit.value = false
  dialogTitle.value = '新增学生'
  form.value = {
    id: '',
    name: '',
    age: '',
    email: ''
  }
  dialogVisible.value = true
}

// 编辑学生
const handleEdit = (row) => {
  isEdit.value = true
  dialogTitle.value = '编辑学生'
  form.value = { ...row }
  dialogVisible.value = true
}

// 提交表单
const handleSubmit = async () => {
  try {
    if (isEdit.value) {
      await request.put(`/students/${form.value.id}`, form.value)
    } else {
      await request.post('/students', form.value)
    }
    dialogVisible.value = false
    getStudents()
  } catch (error) {
    console.error('保存学生失败:', error)
  }
}

// 删除学生
const handleDelete = async (id) => {
  try {
    await request.delete(`/students/${id}`)
    getStudents()
  } catch (error) {
    console.error('删除学生失败:', error)
  }
}

// 页面加载时获取学生列表
onMounted(() => {
  getStudents()
})
</script>
```

### 前后端集成联调

#### 跨域问题解决方案
在后端配置 CORS 中间件：
```csharp
// Program.cs
app.UseCors("AllowAll");
```

#### 开发环境与流程

##### 开发环境配置

1. **后端开发环境**：
   - **操作系统**：Windows 11
   - **开发工具**：Visual Studio 2022
   - **SDK**：.NET 6.0
   - **数据库**：SQL Server 2019
   - **依赖管理**：NuGet

2. **前端开发环境**：
   - **操作系统**：Windows 11
   - **开发工具**：VS Code
   - **Node.js**：v16.17.0
   - **包管理器**：npm
   - **构建工具**：Vite

##### 开发流程

1. **需求分析与设计**：
   - 分析系统需求，确定功能模块
   - 设计数据库表结构
   - 设计前后端接口
   - 设计前端页面布局和交互

2. **后端开发**：
   - 创建 .NET Web API 项目
   - 配置 EF Core 和 Autofac
   - 实现数据实体和 DbContext
   - 实现业务逻辑和 API 控制器
   - 测试 API 接口

3. **前端开发**：
   - 创建 Vue.js 3 项目
   - 配置路由和 Axios
   - 实现页面组件
   - 实现与后端 API 的交互
   - 测试前端功能

4. **前后端联调**：
   - 启动前后端开发服务器
   - 测试 API 接口调用
   - 调试和修复问题
   - 优化系统性能

5. **测试与部署**：
   - 进行功能测试和性能测试
   - 修复测试中发现的问题
   - 准备部署环境
   - 部署前后端应用

#### 联调流程
1. **启动后端服务**：启动 .NET Web API 项目，确保 API 服务正常运行
2. **启动前端服务**：启动 Vue.js 开发服务器，访问前端应用
3. **测试 API 接口**：使用浏览器开发者工具查看网络请求，检查 API 调用是否成功
4. **调试问题**：如果出现问题，查看控制台日志和服务器日志，定位错误原因
5. **优化调整**：根据测试结果，优化前端代码和后端 API

## 五、 实验测试与问题复盘

### 测试范围与测试方法

#### 测试范围
1. **功能测试**：测试各个功能模块是否正常工作
2. **接口测试**：测试 API 接口的正确性
3. **兼容性测试**：测试在不同浏览器中的表现
4. **性能测试**：测试系统的响应速度和并发能力

#### 测试方法
1. **手动测试**：通过浏览器访问前端应用，手动测试各个功能
2. **自动化测试**：使用 PostMan 进行 API 接口自动化测试
3. **性能测试**：使用 JMeter 进行性能测试

### 核心功能测试用例与执行结果

| 测试用例 | 预期结果 | 实际结果 | 测试状态 |
|---------|---------|---------|---------|
| 管理员登录 | 成功登录并跳转到学生管理页面 | 成功登录并跳转 | 通过 |
| 学生登录 | 成功登录并跳转到个人中心 | 成功登录并跳转 | 通过 |
| 查看学生列表 | 显示所有学生信息 | 显示所有学生信息 | 通过 |
| 新增学生 | 成功添加学生并显示在列表中 | 成功添加学生 | 通过 |
| 编辑学生 | 成功修改学生信息 | 成功修改学生信息 | 通过 |
| 删除学生 | 成功删除学生并从列表中移除 | 成功删除学生 | 通过 |
| 查看课程列表 | 显示所有课程信息 | 显示所有课程信息 | 通过 |
| 新增课程 | 成功添加课程并显示在列表中 | 成功添加课程 | 通过 |
| 编辑课程 | 成功修改课程信息 | 成功修改课程信息 | 通过 |
| 删除课程 | 成功删除课程并从列表中移除 | 成功删除课程 | 通过 |
| 查看成绩列表 | 显示所有成绩信息 | 显示所有成绩信息 | 通过 |
| 新增成绩 | 成功添加成绩并显示在列表中 | 成功添加成绩 | 通过 |
| 编辑成绩 | 成功修改成绩信息 | 成功修改成绩信息 | 通过 |
| 删除成绩 | 成功删除成绩并从列表中移除 | 成功删除成绩 | 通过 |
| 学生查看个人信息 | 显示当前学生的个人信息 | 显示当前学生的个人信息 | 通过 |
| 学生查看自己的课程 | 显示当前学生的课程 | 显示当前学生的课程 | 通过 |
| 学生查看自己的成绩 | 显示当前学生的成绩 | 显示当前学生的成绩 | 通过 |

### 实验过程中的典型问题与解决思路

1. **CORS 跨域问题**
   - **问题**：前端请求后端接口时出现跨域错误
   - **解决思路**：在后端配置 CORS 中间件，允许所有来源的请求
   - **解决方案**：
     ```csharp
     // Program.cs
     app.UseCors("AllowAll");
     ```

2. **学生登录失败**
   - **问题**：学生使用密码"1234"登录失败
   - **解决思路**：检查 `AuthController.cs` 中的密码验证逻辑
   - **解决方案**：修改密码验证逻辑，支持"1234"密码
     ```csharp
     if (loginDto.Password != "student123" && loginDto.Password != "1234")
     {
         return Unauthorized("学生ID或密码错误");
     }
     ```

3. **数据库更新问题**
   - **问题**：修改种子数据后，数据库没有更新
   - **解决思路**：了解 EF Core `EnsureCreated()` 方法的行为
   - **解决方案**：EF Core 的 `EnsureCreated()` 只在数据库不存在时创建，需要手动删除数据库或使用迁移命令

4. **Token 失效问题**
   - **问题**：Token 过期后，前端请求失败
   - **解决思路**：在前端添加 Token 过期处理逻辑
   - **解决方案**：在响应拦截器中检查 Token 是否过期，如果过期则跳转到登录页面

### 测试结果分析与优化建议

#### 测试结果分析
1. **功能测试**：所有功能测试用例均通过，系统功能完整
2. **接口测试**：API 接口工作正常，返回数据格式一致
3. **兼容性测试**：在 Chrome、Firefox、Edge 浏览器中表现正常
4. **性能测试**：系统响应速度较快，满足需求

#### 优化建议
1. **添加分页功能**：当数据量较大时，分页功能可以提高系统性能和用户体验
2. **添加搜索功能**：支持按关键词搜索学生、课程等信息
3. **添加数据验证**：在前端和后端都添加数据验证，确保数据的正确性
4. **添加缓存机制**：对频繁访问的数据添加缓存，提高系统性能
5. **完善日志记录**：添加系统日志记录，便于问题排查和系统监控
6. **改进密码存储机制**：当前项目为简化实现，密码未做哈希处理，实际部署需使用 BCrypt 等算法加密，提高系统安全性

## 六、 系统使用说明

### 6.1 登录功能

#### 管理员登录
- **用户名**：admin
- **密码**：admin123
- **登录后页面**：学生管理页面

#### 学生登录
- **用户名**：学生ID（如1001、1002等）
- **密码**：1234
- **登录后页面**：个人中心页面

### 6.2 学生功能

#### 个人信息查看
- 登录后自动进入个人信息页面
- 显示学生基本信息
- 支持查看个人课程和成绩

#### 我的课程
- 显示学生已选课程列表
- 支持查看课程详情

#### 我的成绩
- 显示学生所有课程成绩
- 支持按课程筛选

### 6.3 管理员功能

#### 6.3.1 学生管理
- **功能描述**：
  - 对学生信息进行全面管理
  - 支持学生信息的增删改查操作
  - 新增/编辑学生信息使用对话框形式
  - 支持删除单个学生

- **操作流程**：
  1. 点击"新增学生"按钮打开新增对话框
  2. 填写学生信息，点击"确定"完成添加
  3. 点击列表中"编辑"按钮修改学生信息
  4. 点击列表中"删除"按钮删除学生

#### 6.3.2 课程管理
- **功能描述**：
  - 对课程信息进行全面管理
  - 支持课程信息的增删改查操作
  - 新增/编辑课程使用对话框形式
  - 支持删除单个课程

- **操作流程**：
  1. 点击"新增课程"按钮打开新增对话框
  2. 填写课程信息，点击"确定"完成添加
  3. 点击列表中"编辑"按钮修改课程信息
  4. 点击列表中"删除"按钮删除课程

#### 6.3.3 成绩管理
- **功能描述**：
  - 对学生成绩进行全面管理
  - 支持成绩信息的增删改查操作
  - 新增/编辑成绩使用对话框形式
  - 支持删除单个成绩

- **操作流程**：
  1. 点击"新增成绩"按钮打开新增对话框
  2. 选择学生和课程，填写成绩，点击"确定"完成添加
  3. 点击列表中"编辑"按钮修改成绩信息
  4. 点击列表中"删除"按钮删除成绩

#### 6.3.4 日志页面
- **功能描述**：
  - 展示系统操作日志
  - 支持按时间、操作类型、操作用户筛选
  - 采用红色主题设计，突出日志信息
  - 实时更新日志内容

- **技术实现**：
  - 使用Vue 3组合式API开发
  - 采用Element Plus表格组件
  - 实现了日志数据的实时获取与展示
  - 通过Axios与后端日志API交互

## 七、 实验总结与技术感悟

### 实验核心目标达成情况
1. **技术掌握**：成功掌握了 .NET Web API、EF Code First、Autofac IOC 和 Vue.js 等核心技术
2. **架构理解**：深入理解了前后端分离架构的设计理念与实现方式
3. **项目实战**：完成了一个完整的前后端分离学生管理系统，包括学生管理、课程管理、成绩管理等功能
4. **能力提升**：培养了问题分析与解决能力，提升了全栈开发素养

### 前后端分离与传统架构的差异对比

| 对比项 | 前后端分离架构 | 传统架构（如 .NET Web MVC） |
|-------|--------------|--------------------------|
| **开发模式** | 前后端独立开发，并行进行 | 前后端耦合，顺序开发 |
| **技术栈** | 前后端可以使用不同的技术栈 | 前后端使用相同的技术栈 |
| **部署方式** | 前后端独立部署 | 前后端一起部署 |
| **用户体验** | 前后端分离，前端可以实现更丰富的交互效果 | 前后端耦合，交互效果相对简单 |
| **扩展性** | 便于扩展，支持多端应用 | 扩展性相对较差，不便于支持多端应用 |
| **团队协作** | 便于团队协作，前后端可以由不同的团队开发 | 团队协作相对困难，需要统一技术栈 |

### EF Code First 与 Autofac 的实际应用价值感悟

#### EF Code First 的应用价值
1. **提高开发效率**：从代码生成数据库，简化了数据库操作，不需要手动编写 SQL
2. **便于数据库版本管理**：支持数据迁移，可以方便地管理数据库版本
3. **强类型查询**：支持 LINQ 查询，提供了强类型的查询方式，减少了查询错误
4. **支持多种数据库**：可以轻松切换不同的数据库，提高了系统的灵活性

#### Autofac 的应用价值
1. **降低代码耦合度**：通过依赖注入，降低了代码之间的耦合度，提高了代码的可维护性
2. **提高代码可测试性**：依赖注入便于进行单元测试，可以轻松替换依赖的实现
3. **便于系统扩展**：通过依赖注入，系统可以轻松扩展，添加新的功能模块
4. **支持生命周期管理**：可以灵活配置对象的生命周期，提高系统性能

### 从实验 1 到实验 4 的技术成长梳理

#### 实验 1：EF Code First 数据访问层实现
- **学习内容**：EF Code First 开发模式、实体类设计、DbContext 配置、数据初始化
- **技术成长**：掌握了 EF Code First 的核心概念和使用方法，能够从代码生成数据库

#### 实验 2：.NET Web MVC 5 项目实现
- **学习内容**：.NET Web MVC 5 框架、Model-View-Controller 设计模式、视图开发
- **技术成长**：掌握了 .NET Web MVC 5 框架的使用，能够实现传统的 Web 应用

#### 实验 3：前后端分离项目实现
- **学习内容**：前后端分离架构、.NET Web API、Vue.js、Axios
- **技术成长**：掌握了前后端分离架构的设计理念和实现方式，能够构建 RESTful API 和前端应用

#### 实验 4：Autofac IOC 容器集成
- **学习内容**：Autofac IOC 容器、依赖注入、控制反转
- **技术成长**：掌握了依赖注入的核心概念和使用方法，能够使用 Autofac 容器实现依赖注入

#### 整体技术成长
通过实验 1-4 的学习，我从一个初级开发者成长为一个能够独立开发前后端分离项目的全栈开发者。我掌握了 .NET Web API、EF Code First、Autofac IOC 和 Vue.js 等核心技术，理解了前后端分离架构的设计理念和实现方式，能够构建完整的 Web 应用。

## 八、 附录

### 项目核心配置代码

#### 后端 Program.cs 配置
```csharp
var builder = WebApplication.CreateBuilder(args);

// 配置 Autofac
builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());
builder.Host.ConfigureContainer<ContainerBuilder>(builder =>
{
    // 注册 DbContext
    builder.RegisterType<SchoolContext>().AsSelf().InstancePerLifetimeScope();
    
    // 注册控制器
    builder.RegisterControllers(typeof(Program).Assembly);
});

// 添加服务
builder.Services.AddControllers();
builder.Services.AddDbContext<SchoolContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

var app = builder.Build();

// 配置中间件
app.UseCors("AllowAll");
app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

// 初始化数据库
using (var scope = app.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<SchoolContext>();
    context.Database.EnsureCreated();
}

app.Run();
```

#### 前端 main.js 配置
```javascript
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

const app = createApp(App)

app.use(router)
app.use(ElementPlus)
app.mount('#app')
```

### 实验运行截图与关键日志

#### 登录页面
![登录页面](images/login.png)

#### 学生管理页面
![学生管理页面](images/student_management.png)

#### 课程管理页面
![课程管理页面](images/course_management.png)

#### 成绩管理页面
![成绩管理页面](images/enrollment_management.png)

#### 学生个人中心
![学生个人中心](images/student_profile.png)

### 相关技术文档与参考资料

1. **.NET Web API 文档**：https://docs.microsoft.com/zh-cn/aspnet/core/web-api/
2. **EF Core 文档**：https://docs.microsoft.com/zh-cn/ef/core/
3. **Autofac 文档**：https://autofaccn.readthedocs.io/zh/latest/
4. **Vue.js 文档**：https://v3.vuejs.org/
5. **Element Plus 文档**：https://element-plus.org/zh-CN/
6. **Axios 文档**：https://axios-http.com/zh/docs/intro
7. **RESTful API 设计指南**：https://restfulapi.net/
8. **JWT 文档**：https://jwt.io/introduction/